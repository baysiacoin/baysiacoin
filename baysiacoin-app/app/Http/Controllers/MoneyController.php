<?php namespace App\Http\Controllers;use App\Currency;use App\CurrencyContent;use App\Gateway;use App\UserWallet;use Illuminate\Http\Request;use Illuminate\Support\Facades\DB;use Illuminate\Support\Facades\Auth;use Illuminate\Support\Facades\Log;use Illuminate\Support\Facades\Mail;use Illuminate\Support\Facades\Route;use Illuminate\Support\Facades\Session;use Illuminate\Support\Facades\Lang;use Illuminate\Support\Facades\Config;//use Illuminate\Support\Facades\Request;use App\UserInfo;use App\User;use App\Deposit;use App\Withdraw;use App\Transfer;use App\FeeTrade;use App\Market;use App\Order;use App\Post;use App\Setting;use App\Trade;use App\WalletTimeLimitTrade;use Illuminate\Support\Facades\Validator;use RippleRestAccount;use BaysiaRPCHandler;class MoneyController extends Controller {	/*	|--------------------------------------------------------------------------	| Home Controller	|--------------------------------------------------------------------------	|	| This controller renders your application's "dashboard" for users that	| are authenticated. Of course, you are free to change or remove the	| controller as you wish. It is just here to get your app started!	|	*/	/**	 * Create a new controller instance.	 */	public function __construct()	{		$this->middleware('auth');	}	/**	 * Show the application dashboard to the user.	 *	 * @return Response	 */	public function getIndex()	{		return $this->getBalance();	}	/**	 * Balance	 */	public function getBalance()	{		$user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $gateways = Gateway::all();	    return view('money.balance', ['username' => $user->username, 'wallet_address' => $userWallet['wallet_address'], 'gateways' => $gateways]);	}    /*public function getTrade()    {        $user = Auth::user();        if (!view()->exists('money.trade')) return view()->make('errors.404');        return view('money.trade', ['username' => $user->username]);    }*/	public function getTrade()	{		$user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $base_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $other_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', '!=', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $base_currs = array_flatten($base_currs);        $other_currs = array_flatten($other_currs);        //get trusted currencies and the intersection between db data and them        $rpc_client = new BaysiaRPCHandler;        $trust_currs = $rpc_client->getTrustCurrencies($userWallet['wallet_address']);        $other_currs = array_intersect($other_currs, $trust_currs);        $all_currs = array_merge($base_currs, $other_currs);        $data = array();        if (isset($userWallet['wallet_address'])) {            $data['account'] = $userWallet['wallet_address'];        }        $data['currencies'] = array_values(array_unique($all_currs));//        print_r($data['sell_offers']);exit;        Session::put('isTrade', true);		return view('money.trade', $data);	}    public function postTrade(Request $request) {        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $data = $request->all();        $type = $data['type'];        //$base_gateway = Config::get('conf.base_gateway');        /*         * get baysia address from gateways         */        $p_curr_gateway = $s_curr_gateway = null;        if (isset($data['p_issuer'])) {            $p_curr_gateway = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')                ->where('gateways.name', $data['p_issuer'])                ->where('currencies.name', $data['primaryCurrency'])                ->select('currencies.issuer')                ->first()['issuer'];            if (empty($p_curr_gateway)) {                $p_curr_gateway = $data['p_issuer'];            }        }        if (isset($data['s_issuer'])) {            $s_curr_gateway = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')                ->where('gateways.name', $data['s_issuer'])                ->where('currencies.name', $data['2ndCurrency'])                ->select('currencies.issuer')                ->first()['issuer'];            if (empty($s_curr_gateway)) {                $s_curr_gateway = $data['s_issuer'];            }        }        /*         * consist sell, buy         */        if ($type == 'sell') {            /*             * sell consists of primary currency infos             */            $sell['value'] = $data['sellAmount'];            $sell['currency'] = $data['primaryCurrency'];            $sell['issuer'] = $p_curr_gateway;            /*             * buy consists of secondary currency infos             */            $buy['value'] = $data['sellTotal'];            $buy['currency'] = $data['2ndCurrency'];            $buy['issuer'] = $s_curr_gateway;        } else if ($type == 'buy') {            /*             * sell consists of primary currency infos             */            $sell['value'] = $data['buyTotal'];            $sell['currency'] = $data['2ndCurrency'];            $sell['issuer'] = $s_curr_gateway;            /*             * buy consists of secondary currency infos             */            $buy['value'] = $data['buyAmount'];            $buy['currency'] = $data['primaryCurrency'];            $buy['issuer'] = $p_curr_gateway;        }//        $request->flash();//        print_r(json_encode($buy));/*print_r('<BR>');print_r(json_encode($buy));*/exit;        /*         * make a offer         */        $rpc_client = new BaysiaRPCHandler;        $balances = $rpc_client->getCustomBalances($userWallet['wallet_address'], [COIN_BSC, $sell['currency']], $sell['issuer']);        $request->flash();        if ($sell['currency'] == COIN_BSC && $balances[COIN_BSC] < $sell['value'] + 0.015 || $sell['currency'] != COIN_BSC && $balances[$sell['currency']] < $sell['value']) {            echo json_encode(['result' => LOW_BALANCE]);            exit;        }        list($result, $message) = $rpc_client->doCreateOffer($userWallet['wallet_address'], $userWallet['wallet_secret'], $sell, $buy);        if (!$result) {            echo json_encode(['result' => FAIL, 'message' => $message]);            exit;        }        echo json_encode(['result' => SUCCESS]);        exit;    }    public function postExchange(Request $request) {        $data = $request->all();        $base = explode('/', $data['base']); // JPY/gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        $counter = explode('/', $data['counter']);        if ($base[0] == $counter[0]) {            echo json_encode(['result' => SAME_CURRENCY]);            exit;        }        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $address = $userWallet['wallet_address'];        $secret = $userWallet['wallet_secret'];//        $gateway = Config::get('conf.stellar.issuer_wallet_address');        $src = ($data['src'] == 'base') ? $base : $counter;        $rpc_client = new BaysiaRPCHandler;        $balance = $rpc_client->getCustomBalances($address, $src[0], $src[1]);        if ($balance == 0) {            echo json_encode(['result' => LOW_BALANCE]);            exit;        }        $sell['currency'] = ($data['src'] == 'base') ? $base[0] : $counter[0];        $sell['issuer'] = ($data['src'] == 'base') ? $base[1] : $counter[1];        $sell['value'] = $balance;        $buy['currency'] = ($data['src'] == 'base') ? $counter[0] : $base[0];        $buy['issuer'] = ($data['src'] == 'base') ? $counter[1] : $base[1];        $buy['value'] =  floor($sell['value'] * round($rpc_client->getMarketRate($sell, $buy, true) - 0.000005, 8) * 100000000) / 100000000;//        print_r($rpc_client->getMarketRate($buy, $sell, true));exit;//        print_r($sell);print_r($buy);exit;        list($result , $message) = $rpc_client->doCreateOffer($address, $secret, $sell, $buy);        if (!$result) {            echo json_encode(['result' => 'Failed', 'message' => $message]);            exit;        }        echo json_encode(['result' => SUCCESS]);        exit;    }    /**Delete Account Offers     *     *     */    public function postCancel() {        $user = Auth::user();        $data = \Request::all();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $rpc_client = new BaysiaRPCHandler;        list($result, $message) = $rpc_client->doCancelOffer($userWallet['wallet_address'], $userWallet['wallet_secret'], $data['seq']);        if (!$result) {            print_r(json_encode(['result' => FAIL, 'message' => $message]));        }        print_r(json_encode(['result' => SUCCESS]));        exit;    }    /**	 * History	 */	public function getHistory()	{		return redirect('money/history/fund');	}    public function history_fund(){        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $date_filter = Session::get('HISTORY_FUND_DATE_FILTER', 'day');        $deposits = Deposit::where('user_id', $user->id)->orderBy('id', 'asc')-> paginate(PER_PAGE);        $current_page = Session::get('HISTORY_FUND_CURRENT_PAGE', 1);        if($current_page != $deposits->currentPage() && !mb_strpos(session()->previousUrl(), '/money/history/fund')>0){            return redirect(sprintf("/money/history/fund?page=%d", $current_page));        }        Session::put('HISTORY_FUND_CURRENT_PAGE', $deposits->currentPage());        $data = array("type" => "0", "results" => $deposits, "date_filter" => $date_filter, "wallet_address" => $userWallet['wallet_address']);        return view('money.history', $data);    }    public function history_fund_search(Request $request){        $data = $request->all();        if (isset($data['date_filter']))            Session::put('HISTORY_FUND_DATE_FILTER', $data['date_filter']);        $current_page = 1;        Session::put('HISTORY_FUND_CURRENT_PAGE', 1);        return redirect(sprintf("/money/history/fund?page=%d", $current_page));    }    public function history_trade($type){        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $date_filter = Session::get('HISTORY_TRADE_DATE_FILTER', 'day');        $data = array();        $data['results'] = array();        if ($type == 'order') {            $data['type'] = 1;        } else if ($type == 'transaction') {            $data['type'] = 2;        }        $data['wallet_address'] = $userWallet['wallet_address'];        $data['date_filter'] = $date_filter;        return view('money.history', $data);    }    public function history_withdraw(){        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $date_filter = Session::get('HISTORY_WITHDRAW_DATE_FILTER', 'day');        $withdraw = Withdraw::where('user_id', $user->id)->orderBy('id', 'asc')-> paginate(PER_PAGE);        $current_page = Session::get('HISTORY_WITHDRAW_CURRENT_PAGE', 1);        if($current_page != $withdraw->currentPage() && !mb_strpos(session()->previousUrl(), '/money/history/withdraw')>0){            return redirect(sprintf("/money/history/withdraw?page=%d", $current_page));        }        Session::put('HISTORY_WITHDRAW_CURRENT_PAGE', $withdraw->currentPage());        $data = array("type" => "3", "results" => $withdraw, "date_filter" => $date_filter, "wallet_address" => $userWallet['wallet_address']);        return view('money.history', $data);    }    public function history_withdraw_search(Request $request){        $data = $request->all();        if (isset($data['date_filter']))            Session::put('HISTORY_WITHDRAW_DATE_FILTER', $data['date_filter']);        $current_page = 1;        Session::put('HISTORY_WITHDRAW_CURRENT_PAGE', 1);        return redirect(sprintf("/money/history/withdraw?page=%d", $current_page));    }    public function history_transfer(){        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $date_filter = Session::get('HISTORY_TRANSFER_DATE_FILTER', 'day');        $recv_act = \Request::get('dst_address', '');        if (!!$recv_act) {            $transfers = DB::table('transfers')                ->leftJoin('users_wallet as sender_wallet', 'transfers.sender_id', '=', 'sender_wallet.user_id')                ->leftJoin('users_wallet as receiver_wallet', 'transfers.receiver_id', '=', 'receiver_wallet.user_id')                ->select('wallet_id', 'transaction_id', 'amount', 'paid', 'transfers.updated_at', 'sender_wallet.wallet_address as sender_wallet_address', 'receiver_wallet.wallet_address as receiver_wallet_address')                ->where('sender_wallet.user_id', $user->id)                ->where('receiver_wallet.wallet_address', $recv_act)                ->paginate(PER_PAGE);                } else {            $transfers = DB::table('transfers')                ->leftJoin('users_wallet as sender_wallet', 'transfers.sender_id', '=', 'sender_wallet.user_id')                ->leftJoin('users_wallet as receiver_wallet', 'transfers.receiver_id', '=', 'receiver_wallet.user_id')                ->select('wallet_id', 'transaction_id', 'amount', 'paid', 'transfers.updated_at', 'sender_wallet.wallet_address as sender_wallet_address', 'receiver_wallet.wallet_address as receiver_wallet_address')                ->where('sender_wallet.user_id', $user->id)                ->paginate(PER_PAGE);        }        //        $transfers = Transfer::orderBy('updated_at', 'asc')-> paginate(PER_PAGE);//        $tmp = array();//        foreach ($transfers as $transfer) {//            $userWallet = UserWallet::where('user_id', $user->id)->first();//            $tmp = $transfer;//            $tmp['dstAddress'] = $userWallet['wallet_address'];//        }//        $transfers = $tmp;        Session::put('HISTORY_TRANSFER_CURRENT_PAGE', $transfers->currentPage());        $current_page = Session::get('HISTORY_TRANSFER_CURRENT_PAGE', 1);        if($current_page != $transfers->currentPage() && !mb_strpos(session()->previousUrl(), '/money/history/transfer')>0){            return redirect(sprintf("/money/history/transfer?page=%d", $current_page));        }//        print_r($transfers);exit;        $data = array("type" => "4", "results" => $transfers, "date_filter" => $date_filter, "wallet_address" => $userWallet['wallet_address']);//        print_r($data);exit;        return view('money.history', $data);    }    public function history_transfer_search(){        $user = Auth::user();        $request = \Request::all();        if (isset($request['date_filter'])) {            Session::put('HISTORY_TRANSFER_DATE_FILTER', $request['date_filter']);        }        if (isset($request['wallet_address_filter'])) {                        $receiver_wallet =  $request['wallet_address_filter'];                    }        $current_page = 1;        Session::put('HISTORY_TRANSFER_CURRENT_PAGE', 1);        return redirect(sprintf("/money/history/transfer?page=%d&dst_address=%s", $current_page, $receiver_wallet));    }    /**	 * Send	 */	public function getTransfer($to_account = null)	{        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        //$base_currs = Config::get('conf.base_currencies');        $base_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $auth_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', '!=', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $base_currs = array_flatten($base_currs);        $auth_currs = array_flatten($auth_currs);        //get trusted currencies and the intersection between db data and them        $rpc_client = new BaysiaRPCHandler;        $trust_currs = $rpc_client->getTrustCurrencies($userWallet['wallet_address']);        $auth_currs = array_intersect($auth_currs, $trust_currs);        $all_currs = array_merge($base_currs, $auth_currs);        $data['currencies'] = array_values(array_unique($all_currs));        $data['username'] = $user->username;        $data['to_account'] = $to_account;		return view('money.send', $data);	}    /**     * @param Request $request     * @return \Illuminate\Http\RedirectResponse     */    public function postTransfer(Request $request) {        $user = Auth::user();        $data = $request->all();        $validator = UserInfo::validator($data, array('applicant_name', 'fund_amount', 'withdraw_amount'), ['transfer_amount' => 'required|numeric|min:0|max:1000000000']);        if ($validator->fails()){            return redirect('/money/transfer')->withInput()->withErrors($validator);        }        if (!isset($data['issuer'])) {            $data['issuer'] = null;        }        $data['issuer'] = trim($data['issuer']);        $data['wallet_address'] = trim($data['wallet_address']);        $user_wallet = UserWallet::where('wallet_address', $data['wallet_address'])->first();        if (empty($user_wallet)) {            return redirect('/money/transfer')->with('result', FAIL);        }        $receiver_wallet_address = $user_wallet['wallet_address'];        $date = date('Y-m-d H:i:s');        // 10桁の取引ＩＤ        $transaction_id = mt_rand(1000000000, 9999999999);        /*$transfer = Transfer::firstOrNew([            'sender_id' => $user->id,            'receiver_id' => $userWallet->user_id,            'currency' => $data['curr'],            'transaction_id' => $transaction_id,            'amount' => $data['transfer_amount'],        ]);*/        if (!empty($data['issuer'])) {            $issuer = Gateway::where('name', $data['issuer'])->first()['owner_address'];        } else {            $issuer = null;        }        if (empty($issuer)) {            $issuer = $data['issuer'];            //return redirect('/money/transfer')->withErrors(['There is no gateway like ' . $data['issuer'] . '.']);        }        $user_wallet = UserWallet::where('user_id', $user->id)->first();        $sender_wallet_address = $user_wallet['wallet_address'];        $sender_wallet_secret = $user_wallet['wallet_secret'];        $pay_amount = ['value' => $data['transfer_amount'], 'currency' => $data['curr'], 'issuer' => $issuer];        $rpc_client = new BaysiaRPCHandler;        if ($receiver_wallet_address != $pay_amount['issuer'] && $data['curr'] != COIN_BSC) {            $limit_amount = $rpc_client->getCustomLimitAmount($receiver_wallet_address, $pay_amount['currency'], $pay_amount['issuer']);            if (is_null($limit_amount) || $limit_amount === (float) 0) {                return redirect('/money/transfer')->with(['result' => FAIL, 'message' => 'The currency is not trusted!']);            }        }        if ($sender_wallet_address != $pay_amount['issuer']) {            $balance = $rpc_client->getCustomBalances($sender_wallet_address, $pay_amount['currency'], $pay_amount['issuer']);            if (is_null($balance) || $balance < $pay_amount['value'] ) {                return redirect('/money/transfer')->with(['result' => FAIL, 'message' => 'The balance is not enough!']);            }        }        list($result, $message) = $rpc_client->doPayment($sender_wallet_address, $sender_wallet_secret, $receiver_wallet_address, $pay_amount);        if (!$result) {            return redirect('/money/transfer')->with(['result' => FAIL, 'message' => $message]);        }        return redirect('/money/transfer')->with('result', SUCCESS);    }	/**	 * Fund	 */	public function getFund()	{        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $base_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $other_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', '!=', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $base_currs = array_flatten($base_currs);        $other_currs = array_flatten($other_currs);        //get trusted currencies and the intersection between db data and them        $rpc_client = new BaysiaRPCHandler;        $trust_currs = $rpc_client->getTrustCurrencies($userWallet['wallet_address']);        $other_currs = array_intersect($other_currs, $trust_currs);        $all_currs = array_merge($base_currs, $other_currs);        $data['currencies'] = array_values(array_unique($all_currs));        $data['newtag'] = substr(time(), 3) . rand(10, 99);        return view('money.fund', $data);	}		public function postFund(Request $request){        $user = Auth::user();        $data = $request->all();        $validator = UserInfo::validator($data, array('withdraw_amount'));        $validator->sometimes('tag', 'required|numeric', function($input){            return $input['curr'] == 'STR' || $input['curr'] == 'XRP';        });        $validator->sometimes('ext_addr', 'required', function($input){            return $input['curr'] == 'STR' || $input['curr'] == 'XRP' || $input['curr'] == 'BTC';        });        $validator->sometimes('fund_amount', 'min:100', function($input){            return $input['curr'] != 'STR' && $input['curr'] != 'XRP' && $input['curr'] != 'BTC';        });        if ($validator->fails()){            return redirect('/money/fund')->withInput()->withErrors($validator);        }        $issuer = (object) ['wallet_address' => ''];        if (isset($data['issuer']) && !empty($data['issuer'])) {            $issuer = Gateway::leftJoin('users_wallet', 'users_wallet.wallet_address', '=', 'gateways.owner_address')                ->where('gateways.name', $data['issuer'])                ->orWhere('users_wallet.wallet_address', $data['issuer'])                ->select('users_wallet.wallet_address', 'users_wallet.user_id')                ->first();        }        $date = date('Y-m-d H:i:s');        // 10桁の取引ＩＤ        $transaction_id = mt_rand(1000000000, 9999999999);        $deposit = Deposit::create([]);        $deposit->user_id = $user->id;        $deposit->currency = $data['curr'];        $deposit->issuer = $issuer->wallet_address;        if ($data['curr'] == 'STR' || $data['curr'] == 'XRP' || $data['curr'] == 'BTC') {            $deposit->tag = $data['tag'];            $deposit->external_address = $data['ext_addr'];        }        $deposit->transaction_id = $transaction_id;        $deposit->amount = $data['fund_amount'];        $deposit->name = $data['applicant_name'];        $deposit->paid = DEPOSIT_REQUESTED;        $deposit->created_at = $date;        $deposit->save();                $request->flash();        $issuer_info = UserInfo::leftJoin('users_wallet', 'users_wallet.user_id', '=', 'users_info.user_id')            ->where('wallet_address', $deposit->issuer)            ->select('bankname', 'branchname', 'accounttype', 'accountnumber', 'accountname')            ->first()            ->toArray();        $issuer_info['accounttype'] = ($issuer_info['accounttype'] == 2) ? trans('message.register.accounttype_current') : trans('message.register.accounttype_general');        $alert_message = "";        if (Session::get('locale') == 'en') {            foreach ($issuer_info as $item) {                $alert_message .= ' ' . $item;            }            $alert_message = trans('money.fund.ask_deposit') . $alert_message . '.';        } else /*if (Session::get('locale') == 'ja') */{            foreach ($issuer_info as $item) {                $alert_message .= $item;            }            if (Session::get('locale') == 'cn') {                $alert_message =  trans('money.fund.ask_deposit1') . $alert_message . trans('money.fund.ask_deposit2');            } else {                $alert_message =  $alert_message . trans('money.fund.ask_deposit');            }        }        // get the gateways user information        $receiver_info = User::where('id', $issuer->user_id)->select('email', 'firstname', 'lastname')->first()->toArray();        // mail to gateways when user request a fund        $mailData = [            'type' => DEPOSIT_REQ_NOTIFICATION,            'name' => $data['applicant_name'],            'amount' => $data['fund_amount'],            'currency' => $data['curr'],            'receiver_firstname' => $receiver_info['firstname'],            'receiver_lastname' => $receiver_info['lastname'],        ];        $email = $receiver_info['email'];//        $email = 'nika90426@gmail.com';        Mail::queue('emails.notify2agent', $mailData, function($message) use ($email) {            $message->to($email)->subject(trans('message.mail.notify_deposit2agent'));        });        return redirect('/money/fund')->with(['result' => SUCCESS, 'alert_message' => $alert_message]);	}	/**	 * Withdrawal	 */	public function getWithdraw()	{        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        $base_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $other_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where('currencies.type', '!=', BASE_CURRENCY)            ->where('currencies.approval', CURR_TOP10_APPROVED)            ->select('currencies.name')            ->get()            ->toArray();        $base_currs = array_flatten($base_currs);        $other_currs = array_flatten($other_currs);        //get trusted currencies and the intersection between db data and them        $rpc_client = new BaysiaRPCHandler;        $trust_currs = $rpc_client->getTrustCurrencies($userWallet['wallet_address']);        $other_currs = array_intersect($other_currs, $trust_currs);        $all_currs = array_merge($base_currs, $other_currs);        $data['currencies'] = array_values(array_unique($all_currs));	    return view('money.withdraw', $data);	}        public function postWithdraw(Request $request){        $user = Auth::user();        $userInfo = UserInfo::where('user_id', $user->id)->first();        $data = $request->all();        //$validator = UserInfo::validator($data, array('applicant_name', 'fund_amount'), ['withdraw_amount' => 'required|numeric|min:0|max:'.round($userInfo->balance / (1+FEE), 4, PHP_ROUND_HALF_UP)]);        /*$validator = UserInfo::validator($data, array('applicant_name', 'fund_amount'));        if ($validator->fails()){            return redirect('/money/withdraw')->withInput()->withErrors($validator);        }*/        $validator = UserInfo::validator($data, array('fund_amount'));        $validator->sometimes('tag', 'required|numeric', function($input){            return $input['curr'] == 'STR' || $input['curr'] == 'XRP';        });        $validator->sometimes('ext_addr', 'required', function($input){            return $input['curr'] == 'STR' || $input['curr'] == 'XRP' || $input['curr'] == 'BTC';        });        $validator->sometimes('withdraw_amount', 'min:100', function($input){            return $input['curr'] != 'STR' && $input['curr'] != 'XRP' && $input['curr'] != 'BTC';        });        if ($validator->fails()){            return redirect('/money/withdraw')->withInput()->withErrors($validator);        }        /*         * get currency issuer address, secret         */        /*$gateway = UserWallet::leftJoin('gateways', 'gateways.owner_address', '=', 'users_wallet.wallet_address')            ->leftJoin('currencies', 'gateways.owner_address', '=', 'currencies.issuer')            ->where(['currencies.name' => $data['curr'], 'currencies.approval' => CURR_TOP10_APPROVED])            ->select('users_wallet.wallet_address', 'users_wallet.wallet_secret')            ->first();*/        $issuer = (object) ['wallet_address' => ''];        if (isset($data['issuer']) && !empty($data['issuer'])) {            $issuer = Gateway::leftJoin('users_wallet', 'users_wallet.wallet_address', '=', 'gateways.owner_address')                ->where('gateways.name', $data['issuer'])                ->orWhere('users_wallet.wallet_address', $data['issuer'])                ->select('users_wallet.wallet_address', 'users_wallet.user_id')                ->first();        }        /*if (empty($gateway) || empty($gateway['wallet_address'])) {            return redirect()->back()->with(['result' => FAIL, 'message' => 'Gateway\'s Wallet is Empty!']);        }*/        $userWallet = UserWallet::where('user_id', $user->id)->first();        $address = $userWallet->wallet_address;        $secret = $userWallet->wallet_secret;        $amount['value'] = $data['withdraw_amount'];        $amount['currency'] = $data['curr'];        $amount['issuer'] = $issuer->wallet_address;        $rpc_client = new BaysiaRPCHandler;        $balance = $rpc_client->getCustomBalances($address, $amount['currency'], $amount['issuer']);        /*         * check balance         */        if ($balance < $amount['value']) {            return redirect()->back()->withInput()->with(['result' => LOW_BALANCE]);        }        /*         * do payment         */        list($result, $message) = $rpc_client->doPayment($address, $secret, $amount['issuer'], $amount);        if (!$result) {            return redirect()->back()->with(['result' => FAIL, 'message' => $message]);        }        $date = date('Y-m-d H:i:s');        $transaction_id = mt_rand();        $withdraw = Withdraw::create([]);        $withdraw->user_id = $user->id;        $withdraw->currency = $amount['currency'];        $withdraw->issuer = $amount['issuer'];        $withdraw->fee_amount = round($amount['value'] * FEE, 4, PHP_ROUND_HALF_UP);        $withdraw->receive_amount = $amount['value'] - $withdraw->fee_amount ;        $withdraw->amount = $amount['value'] ;        if ($data['curr'] == 'STR' || $data['curr'] == 'XRP' || $data['curr'] == 'BTC') {            $withdraw->tag = $data['tag'];            $withdraw->external_address = $data['ext_addr'];        }        $withdraw->name = $data['applicant_name'];        $withdraw->accountname = $userInfo->accountname;        $withdraw->created_at = $date;        $withdraw->transaction_id = $transaction_id;        $withdraw->status = WITHDRAW_REQUESTED;        $withdraw->save();        // get the gateways user information        $receiver_info = User::where('id', $issuer->user_id)->select('email', 'firstname', 'lastname')->first()->toArray();        // mail to gateways when user request a fund        $mailData = [            'type' => WITHDRAW_REQ_NOTIFICATION,            'name' => $data['applicant_name'],            'amount' => $data['withdraw_amount'],            'currency' => $data['curr'],            'receiver_firstname' => $receiver_info['firstname'],            'receiver_lastname' => $receiver_info['lastname'],        ];        $email = $receiver_info['email'];//        $email = 'nika90426@gmail.com';        Mail::queue('emails.notify2agent', $mailData, function($message) use ($email) {            $message->to($email)->subject(trans('message.mail.notify_withdrawal2agent'));        });        return redirect('/money/withdraw')->withInput()->with(['result' => SUCCESS]);    }    public function viewAccount($account = '') {        $data['account'] = $account;        return view('money.view', $data);    }    protected function _getAccount($userID)    {        if (!isset($userID) || empty($userID)) {            return new RippleRestAccount('', null);        }        // ユーザのripple情報取得        $userInfo = UserInfo::where('user_id', '=', $userID)->first();        if(isset($userInfo)) {            // ripple情報の取得が失敗した場合            if (empty($userInfo->ripple_address) || empty($userInfo->ripple_secret)) {                return new RippleRestAccount('', null);            }        }else{            return new RippleRestAccount('', null);        }        return new RippleRestAccount($userInfo->ripple_address, $userInfo->ripple_secret);    }    public function getGateway() {        $user = Auth::user();        $user_wallet = UserWallet::where('user_id', $user->id)->first();        $all_currs = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->select('currencies.name')            ->get()            ->toArray();        $all_currs = array_flatten($all_currs);        $all_gateways = Gateway::select('name', 'owner_address')->get();        $data['all_currs'] = array_values(array_unique($all_currs));        $data['gateways'] = $all_gateways;        $data['wallet_address'] = $user_wallet['wallet_address'];        $data['page'] = Session::pull('page', 'trust');//        $data['page'] = Session::pull('page', 'currency');        return view('money.gateway', $data);    }    public function postGateway(Request $request) {        $data = $request->all();        Validator::extend('not_default_gateway', function($attribute, $value, $parameters = null) {            return !($attribute == 'new_gateway' && !strcasecmp(Config::get('conf.base_gateway'), $value));        });        $v = Validator::make($data, [            'new_gateway' => 'sometimes|required|max:50|not_default_gateway',            'curr_type' => 'sometimes|required',            'new_curr' => 'sometimes|required|size:3',            'trust_way' => 'sometimes|required',            'trust_curr' => 'sometimes|required',        ], ['new_gateway.not_default_gateway' => 'The gateway name should be different with the default name.']);        $v->sometimes('gateway_name', 'sometimes|required', function($input){            return $input->trust_way == 'native';        });        $v->sometimes('gateway_address', 'sometimes|required', function($input){            return $input->trust_way == 'address';        });        $v->sometimes(['name', 'subject', 'comment'], 'sometimes|required', function($input) {            return $input->curr_type == CURR_BUSINESS_USAGE;        });        $v->sometimes(['period', 'count', 'ratio'], 'sometimes|required|numeric', function($input) {            return $input->curr_type == CURR_BUSINESS_USAGE;        });        if ($v->fails()) {            $request->flash();            return redirect()->back()->withErrors($v->errors())->with('page', $data['page']);        }        $user = Auth::user();        $userWallet = UserWallet::where('user_id', $user->id)->first();        if (!isset($userWallet) || empty($userWallet['wallet_address']) || empty($userWallet['wallet_secret'])) {            redirect()->back()->withErrors([]);        }        if ($data['page'] == 'gateway') {            /*             * insert currency information to db.             * if personal usage, approval will be set to 1, else 0.             */            $gateway = Gateway::firstOrCreate(['owner_address' => $userWallet['wallet_address']]);            $gateway->name = $data['new_gateway'];            $gateway->save();        } else if ($data['page'] == 'currency') {            /*             * insert currency information to db.             * if personal usage, approval will be set to 1, else 0.             */            $currency = Currency::firstOrCreate(['name' => $data['new_curr'], 'issuer' => $userWallet['wallet_address']]);            $currency->type = $data['curr_type'];            if ($data['curr_type'] == CURR_PERSONAL_USAGE) {                $currency->approval = CURR_TOP10_NOT_APPROVED;            } else if ($data['curr_type'] == CURR_BUSINESS_USAGE) {                $sender_name = $data['name'];                $subject = $data['subject'];                $content = $data['comment'];//                $content = str_replace("\r\n","<br/>",$content); //Carriage return//                $content = str_replace("\u0020","&nbsp;",$content); //Space bar//                var_dump($data);exit;                $currency->approval = CURR_TOP10_NOT_APPROVED;                $currency->count = $data['count'];                $currency->period = $data['period'];                $currency->ratio = $data['ratio'];                /*                 * get 10 random users                 * get by ['name'=>'email', ...]                 */                $random_users = $user->getRandomUsers($currency->count);                $currency->token = md5($currency->issuer . time());                $i = 0;                $mailData = [                    'sender_name' => $sender_name,                    'content' => $content,                    'currency' => $currency->name,                    'issuer_address' => $currency->issuer,                    'url' => url('/issue/agree/'. $currency->token),                ];                Log::info('Mail sent to random users...', $random_users);                foreach ($random_users as $name => $email) {                    $mailData['receiver_name'] = $name;                    $mailData['url'] = url('/issue/agree/' . $currency->token . str_pad($i, 2, 0, STR_PAD_LEFT) . '?curr=' . $currency->name . '&issuer='. $currency->issuer);                    Mail::queue('emails.notify4issue', $mailData, function($message) use ($email, $subject) {                        $message->to($email)->subject($subject);                    });                    $i++;                }                /*                 * send me this mail                 */                /*$email = 'nika90426@gmail.com';                $mailData['receiver_name'] = 'Kihm';                $mailData['url'] = url('/issue/agree/' . $currency->token . '?curr=' . $currency->name . '&issuer='. $currency->issuer);                Mail::queue('emails.notify4issue', $mailData, function($message) use ($email, $subject) {                    $message->to($email)->subject($subject);                });*/                $email = 'info@japan.baysiacoin.com';                $mailData['receiver_name'] = 'Shigeki Kakutani';                $mailData['url'] = url('/issue/agree/' . $currency->token . '0' . '?curr=' . $currency->name . '&issuer='. $currency->issuer);                Mail::queue('emails.notify4issue', $mailData, function($message) use ($email, $subject) {                    $message->to($email)->subject($subject);                });                $currency->mail_sent_at = date('Y-m-d h:i:s', time());                $curr_content = CurrencyContent::firstOrCreate(['curr_id' => $currency->id]);                $curr_content->subject = $subject;                $curr_content->sender_name = $sender_name;                $curr_content->content = $content;                $curr_content->save();            }            $currency->save();        } else if ($data['page'] == 'trust') {            if ($data['trust_way'] == 'native') {                $currency = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')                    ->where(['currencies.name' => $data['trust_curr'], 'gateways.name' => $data['gateway_name']])                    ->select('currencies.name', 'currencies.issuer')                    ->first();                if (empty($currency)) {                    return redirect('/money/gateway')->withErrors(['trust' => 'There is no such currency in ' . $data['gateway_name']]);                }                /**                 * trust the currency                 * if the currency is for personal usage, if the count equals 50 trust will be fail, else the count increase 1 and succeed.                 * if the currency is for business usage, if its approved it will succeed.                 **/                if ($currency->type == CURR_PERSONAL_USAGE) {                } else if ($currency->type == CURR_BUSINESS_USAGE && $currency->approval == CURR_TOP10_APPROVED) {                }            } else if ($data['trust_way'] == 'direct') {                $currency = ['name' => $data['trust_curr'], 'issuer' => trim($data['gateway_address'])];            }            $rpc_client = new BaysiaRPCHandler;            /*             * balance check             */            $balance = $rpc_client->getCustomBalances($userWallet->wallet_address, COIN_BSC);            if ($balance <= 0.015) {                return redirect('/money/gateway')->withErrors(['trust' => 'Low Base Balance']);            }            list($result, $message) = $rpc_client->doTrustSet($userWallet->wallet_address, $userWallet->wallet_secret, $currency['name'], $currency['issuer']);            if (!$result) {                return redirect('/money/gateway')->withErrors(['trust' => 'Trust Failed']);            }        }        $request->flash();        return redirect('/money/gateway')->with(['page' => $data['page'], 'gateway_settings_success' => 'Gateway settings successfully changed.']);    }    /*     * get gateways of authorized currency     */    public function getGatewayList($curr) {        $gateways = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where(['currencies.name' => $curr, 'currencies.approval' => CURR_TOP10_APPROVED])            ->select('gateways.name', 'gateways.owner_address')            ->get();        echo json_encode($gateways);        exit;    }    /*     * get gateways of authorized and unauthorized currency     */    public function getGatewayList2($curr) {        $gateways = Currency::leftJoin('gateways', 'currencies.issuer', '=', 'gateways.owner_address')            ->where(['currencies.name' => $curr])            ->select('gateways.name', 'gateways.owner_address')            ->get();        echo json_encode($gateways);        exit;    }    /*     * get gateways of authorized and unauthorized currency for sepecified currrency and trustlines     */    public function getGatewayList3($curr) {        $tmp = [];        $user = Auth::user();        $gateways = Gateway::leftJoin('currencies', 'currencies.issuer', '=', 'gateways.owner_address')            ->where(['currencies.name' => $curr])            ->select('gateways.name', 'gateways.owner_address', 'currencies.approval as authorized')            ->get();        $user_wallet = UserWallet::where('user_id', $user->id)->first();        $rpc_client = new BaysiaRPCHandler;        foreach ($gateways as $gateway) {            $limit_amount = $rpc_client->getCustomLimitAmount($user_wallet['wallet_address'], $curr, $gateway['owner_address']);            if ($limit_amount > 0)                $gateway['trust'] = true;            else                $gateway['trust'] = false;            $tmp[] = $gateway;        }        echo json_encode($tmp);        exit;    }    /*     * trust     * method = ajax post     */    public function postTrust(Request $request) {        $data = $request->all();        /*if (!isset($data['curr']) || !isset($data['gateway'])) {            echo json_encode(['result' => FAIL]);            exit;        }*/        $remove = isset($data['remove']) ? $data['remove'] : false;        $user = Auth::user();        $user_wallet = UserWallet::where('user_id', $user->id)->first();        /*         * add trustline from edit_user to self         */        $rpc_client = new BaysiaRPCHandler;        list($result, $message) = $rpc_client->doTrustSet($user_wallet['wallet_address'], $user_wallet['wallet_secret'], $data['curr'], $data['gateway'], $remove);        if (!$result) {            echo json_encode(['result' => FAIL, 'message' => $message]);            exit;        }        echo json_encode(['result' => SUCCESS]);        exit;    }    /**     * get account offers     * @param Request $request     */    public function getRawAccountOffers(Request $request) {        $user = Auth::user();        $user_wallet = UserWallet::where('user_id', $user->id)->first();        $rpc_client = new BaysiaRPCHandler;        list($result, $message) = $rpc_client->getRawAccountOffers($user_wallet['wallet_address']);        if (empty($result)) {            $result = ['status' => FAIL, 'message' => $message];        } else {            $result = ['raw' => $result, 'status' => SUCCESS, 'message' => $message];        }        print_r(json_encode($result));        exit;    }    /**     * get raw offers     * @param Request $request     */    public function getRawOffers(Request $request) {        $data = $request->all();        /*         * ['gets' => ['currency'=>BSC], 'pays' => ['currency'=>JPY, 'issuer'=>gXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX]]         */        $sell = $data['gets'];        $buy = $data['pays'];        $rpc_client = new BaysiaRPCHandler;        list($result, $message) = $rpc_client->getRawOffers($sell, $buy);        if (empty($result)) {            $result = ['status' =>FAIL, 'message' => $message];        } else {            $result = ['raw' => $result, 'status' => SUCCESS, 'message' => $message];        }        print_r(json_encode($result));        exit;    }    /*     * get raw balances     */    public function getRawBalances(Request $request) {        $user = Auth::user();        $user_wallet = UserWallet::where('user_id', $user->id)->first();        $data = $request->only('base');        if ($data['base'] == 'true') {            $base = true;        } else {            $base = false;        }        $rpc_client = new BaysiaRPCHandler;        list($result, $message) = $rpc_client->getRawBalances($user_wallet['wallet_address'], $base);        if (empty($result)) {            $result = ['status' =>FAIL, 'message' => $message];        } else {            $result = ['raw' => $result, 'status' => SUCCESS, 'message' => $message];        }        print_r(json_encode($result));        exit;    }    public function postReceiveMessage(Request $request) {        $data = json_decode($request->all(), true);        Log::info($data);        print_r($data);exit;    }    public function getReceiveMessage(Request $request) {//        $data = json_decode($request->all(), true);        $data = ['asdf', 'asdfdsf'];        $csvFile = fopen("D:/user.txt", 'w');        fputcsv($csvFile, $data);        fclose($csvFile);        print_r($data);exit;    }}